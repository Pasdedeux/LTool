<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LitFramework</name>
    </assembly>
    <members>
        <member name="T:LitFramework.FrameworkConfig">
            <summary>
            框架控制参数
            </summary>
        </member>
        <member name="F:LitFramework.FrameworkConfig.TargetFrameRate">
            <summary>
            设置目标帧率
            </summary>
        </member>
        <member name="F:LitFramework.FrameworkConfig.vSyncCount">
            <summary>
            开启垂直同步。默认为0-不开启，1-Every VBlank（每个VBlank计算一帧）,2-Every Second VBlank（每两个VBlank计算一帧）
            </summary>
        </member>
        <member name="F:LitFramework.FrameworkConfig.DelayFuncDetectInterver">
            <summary>
            延迟调用函数计时检测间隔
            </summary>
        </member>
        <member name="F:LitFramework.FrameworkConfig.UseDelayFuncPreciseDetect">
            <summary>
            开启使用逐帧遍历延迟函数调用。默认为false
            </summary>
        </member>
        <member name="F:LitFramework.FrameworkConfig.renderingType">
            <summary>
            当前项目是否是URP
            </summary>
        </member>
        <member name="F:LitFramework.FrameworkConfig.TouchDetectUI">
            <summary>
            触碰/点击忽略UI。默认为true
            </summary>
        </member>
        <member name="F:LitFramework.FrameworkConfig.UGUIOpt">
            <summary>
            开启UGUI组件优化（仅对象创建时）
            </summary>
        </member>
        <member name="T:LitFramework.GameFlow.GameFlowController">
            <summary>
            游戏主流程控制器，用于场景加载、跳转等命令合集
            </summary>
        </member>
        <member name="M:LitFramework.GameFlow.GameFlowController.ChangeScene(System.Int32,System.Action,System.Action,System.String,System.Boolean,System.Single,System.Boolean,System.Boolean)">
            <summary>
            加载场景，这里使用的async加载方式
            </summary>
            <param name="sceneID"></param>
            <param name="callBackBeforeChanging"></param>
            <param name="callBackAfterChanging"></param>
            <param name="loadingUIPath"></param>
            <param name="needFading"></param>
            <param name="fadingTime"></param>
            <param name="isHot"></param>
            <param name="isAdditive"></param>
        </member>
        <member name="M:LitFramework.GameFlow.GameFlowController.ChangeScene(System.String,System.Action,System.Action,System.String,System.Boolean,System.Single,System.Boolean,System.Boolean)">
            <summary>
            加载场景，这里使用的async加载方式
            </summary>
            <param name="sceneID"></param>
            <param name="callBackBeforeChanging"></param>
            <param name="callBackAfterChanging"></param>
            <param name="loadingUIPath"></param>
            <param name="needFading"></param>
            <param name="fadingTime"></param>
            <param name="isHot"></param>
            <param name="isAdditive"></param>
        </member>
        <member name="M:LitFramework.GameFlow.Manager.SceneLoadManager.LoadSceneAsync(System.Int32,System.Boolean)">
            <summary>
            异步加载场景
            </summary>
            <param name="sceneID"></param>
            <param name="isAdditive"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.GameFlow.Manager.SceneLoadManager.LoadSceneAsync(System.String,System.Boolean)">
            <summary>
            异步加载场景
            </summary>
            <param name="sceneID"></param>
            <param name="isAdditive"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.GameFlow.Manager.SceneLoadManager.LoadScene(System.Int32,System.Boolean)">
            <summary>
            同步加载场景
            </summary>
            <param name="sceneID"></param>
        </member>
        <member name="M:LitFramework.GameFlow.Manager.SceneLoadManager.LoadScene(System.String,System.Boolean)">
            <summary>
            同步加载场景
            </summary>
            <param name="sceneID"></param>
        </member>
        <member name="T:LitFramework.GameFlow.LoadingTaskModel">
            <summary>
            Loading 加载任务数据类，用于承接Loading进度条的中间加载任务
            执行时机由UI界面驱动
            </summary>
        </member>
        <member name="M:LitFramework.GameFlow.LoadingTaskModel.AddTask(System.Int32,System.Func{System.Boolean},System.Boolean)">
            <summary>
             在指定加载进度位置执行代码 
             
            【不要手动添加0-5/100的回调函数，0-5默认为场景加载，100默认为加载进度条结束时的回调】
            </summary>
            <param name="framePercent">指定的百分比</param>
            <param name="funcCallBack">需要执行的回调函数</param>
            <param name="forceReplace">忽略限制，按参数信息赋值</param>
        </member>
        <member name="M:LitFramework.GameFlow.LoadingTaskModel.TryGetTask(System.Int32)">
            <summary>
            尝试查询并取出任务
            </summary>
            <param name="framePercent"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.GameFlow.LoadingTaskModel.ClearTask">
            <summary>
            清楚本次UI登记的任务
            </summary>
        </member>
        <member name="T:LitFramework.LitTool.AnimBundle">
            <summary>
            UI/场景动画包。存放一些预设的动画
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.AnimBundle.IGenerateTargetUI(UnityEngine.Vector3,UnityEngine.Vector3,System.Int32,System.Single,System.Single,System.Single,System.String,UnityEngine.Transform,System.Action,System.Single)">
            <summary>
            在目标位置炸开多个UI元素，等待固定时间后，飞向指定区域
            </summary>
            <param name="from">起点</param>
            <param name="to">终点</param>
            <param name="num">数量</param>
            <param name="range">范围</param>
            <param name="explodeTime">炸开时间</param>
            <param name="flyTime">飞到终点所需时间</param>
            <param name="spwanObjName">预制名称</param>
            <param name="parnet">设置的父节点</param>
            <param name="oneNumFun">每一颗飞到终点时执行的事情</param>
            <param name="secondsTime">炸开后等多久开始飞</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.AssetPathManager.GetPersistentDataPath(System.String,System.Boolean)">
            <summary>
             获取外部persistant路径+"//"
            </summary>
            <param name="filePath">要加载的文件名</param>
            <param name="useUri">true-用于www/unitywebrequest加载路径,  false-用于FileInfo FileStream</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.AssetPathManager.GetStreamAssetDataPath(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="filePath">要加载的文件名</param>
            <param name="useUri">true-用于www/unitywebrequest加载路径,  false-用于FileInfo FileStream</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.AssetPathManager.GetTemporaryCachePath(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="filePath">要加载的文件名</param>
            <param name="useUri">true-用于www/unitywebrequest加载路径,  false-用于FileInfo FileStream</param>
            <returns></returns>
        </member>
        <member name="F:LitFramework.LitTool.DocumentAccessor.ReadTextAdditionalCondition">
            <summary>
            参数1-解析出的一条完整信息
            参数2-以解析出的信息第一个元素为键，整条消息作为值构建的字典   
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.CheckRoute(System.String)">
            <summary>
            依次检查 PersistentDataPath、TemporaryCachePath、StreamAssetDataPath三个地址，如果都没有，则返回StreamAssetDataPath
            </summary>
            <param name="fileName">以上三个地址下，子目录路径。例如：csv/csvList.txt</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.WriteFile(System.Text.StringBuilder,System.String)">
            <summary>
            写入文件到目标地址
            </summary>
            <param name="sb"></param>
            <param name="targetPath"></param>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.ReadFile(System.String)">
            <summary>
            读取目标地址文件
            </summary>
            <param name="targetPath">完整地址+名称</param>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.SaveAsset2LocalFile(System.String,System.Byte[])">
            <summary>
            保存二进制文件资源到本地  例如  SaveAsset2LocalFile( path , w.bytes );
            </summary>
            <param name="dataPath">完整目标地址，例如：AssetPathManager.Instance.GetPersistentDataPath( "level.dat", false ) </param>
            <param name="info">bytes数组</param>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.SaveAsset2LocalFileByJson(System.Object,System.String)">
            <summary>
            存储JSON数据到本地文件
            </summary>
            <param name="jsonData">需要被JSON化的类实例</param>
            <param name="dataPath">完整地址。例如：AssetPathManager.Instance.GetPersistentDataPath( "level.dat", false )</param>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.IsExists(System.String)">
            <summary>
            判定特定路径下指定文件是否存在
            </summary>
            <param name="fileFullPath">完整路径。例如：AssetPathManager.Instance.GetPersistentDataPath( "csv/Map.csv", false ) </param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.ILoadAsset(System.String,System.Action{UnityEngine.Networking.UnityWebRequest},System.Action{UnityEngine.Networking.UnityWebRequest})">
            <summary>
            协程加载
            </summary>
            <param name="path">例如：AssetPathManager.Instance.GetStreamAssetDataPath("csv/csvList.csv")</param>
            <param name="callBack"></param>
            <param name="errorCallBack"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.ILoadAsset(System.String,System.Action{System.String},System.Action{UnityEngine.Networking.UnityWebRequest})">
            <summary>
            协程加载
            </summary>
            <param name="path">例如：AssetPathManager.Instance.GetStreamAssetDataPath("csv/csvList.csv")</param>
            <param name="callBack"></param>
            <param name="errorCallBack"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.LoadAsset(System.String,System.Action{System.String},System.Action{UnityEngine.Networking.UnityWebRequest})">
            <summary>
            同步加载
            </summary>
            <param name="path">AssetPathManager.Instance.GetStreamAssetDataPath("csv/csvList.csv")</param>
            <param name="callBack"></param>
            <param name="errorCallBack"></param>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.LoadAsset(System.String,System.Action{UnityEngine.Networking.UnityWebRequest},System.Action{UnityEngine.Networking.UnityWebRequest})">
            <summary>
            同步加载
            </summary>
            <param name="path">AssetPathManager.Instance.GetStreamAssetDataPath("csv/csvList.csv")</param>
            <param name="callBack"></param>
            <param name="errorCallBack"></param>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.WWWLoading(System.String,System.Action{UnityEngine.WWW})">
            <summary>
            www加载，Unity版本
            </summary>
            <param name="filePath">包含IP地址在内（网络请求时）的完整地址</param>
            <param name="callBack">加载完成后的回调</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.WWWLoadingWithWaiting(System.String,System.Action{UnityEngine.WWW})">
            <summary>
            www加载
            </summary>
            <param name="filePath">包含IP地址在内（网络请求时）的完整地址</param>
            <param name="callBack">加载完成后的回调</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.DownLoadFromFTP(System.String,System.Collections.Generic.List{System.String},System.String,System.String)">
            <summary>
            FTP 下载器。同步方法会线程阻塞，用于加载少量文件
            </summary>
            <param name="ftpIP">FTP服务器IP地址+端口。最后需要带上"/"</param>
            <param name="configsPathsList">待加载文件地址，需要带上后缀。例如XXX/Role.csv</param>
            <param name="name">FTP服务器登陆用户名</param>
            <param name="password">FTP服务器登录密码</param>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.DownLoadFromFTP(System.String,System.String,System.String,System.String)">
            <summary>
            FTP 下载器。同步方法会线程阻塞，用于加载少量文件
            </summary>
            <param name="ftpIP">FTP服务器IP地址+端口。最后需要带上"/"</param>
            <param name="configsNamesList">待加载文件地址，需要带上后缀。例如XXX/Role.csv</param>
            <param name="name">FTP服务器登陆用户名</param>
            <param name="password">FTP服务器登录密码</param>
        </member>
        <member name="M:LitFramework.LitTool.DocumentAccessor.MoveStreamPath2PersistantPath">
            <summary>
            迁移StreamingAsset文件到目录PersisitantPath
            </summary>
        </member>
        <member name="T:LitFramework.LitTool.LitTool">
            <summary>
            工具类
            </summary>
        </member>
        <member name="P:LitFramework.LitTool.LitTool.MonoBehaviour">
            <summary>
            协程全局使用mono
            </summary>
        </member>
        <member name="P:LitFramework.LitTool.LitTool.UsePreciseModeForDelayFunc">
            <summary>
            延迟是否使用精准计时。True - update每帧执行。False - 每间隔_delayFuncWaitTimeInterval时间执行一次延迟方法遍历
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.BindingUpdate">
            <summary>
            LToolUpdate
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.DelayPlayFunction(System.Single,System.Action,System.Boolean,System.Boolean)">
            <summary>
            延迟调用方法
            </summary>
            <param name="time">延迟时间</param>
            <param name="func">延迟时间结束后回调函数。暂不支持主动取消，使用过程中需要注意</param>
            <param name="useIgnoreTimeScale">是否忽略TimeScale，默认为true</param>
            <param name="useUpdate">使用update方式或者协程方式，默认是update方式</param>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.DelayPlayFuncMono(System.Single,System.Action,System.Boolean)">
            <summary>
            延迟调用方法（协程方案）
            </summary>
            <param name="time">等待时间，秒</param>
            <param name="func">时间到了回调函数</param>
            <param name="realTime">是否是真实时间（忽略TimeScale）</param>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.WaitUntilFunction(System.Func{System.Boolean},System.Action)">
            <summary>
            WaitUtil方法
            </summary>
            <param name="conditionFunc">通过需要的判定条件</param>
            <param name="func">通过达成后的回调函数</param>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.DelayPlayFuncUpdate(System.Single,System.Action,System.Boolean)">
            <summary>
            延迟调用方法（Update计时方案）
            </summary>
            <param name="time">等待时间，秒</param>
            <param name="func">时间到了回调函数</param>
            <param name="realTime">是否是真实时间（忽略TimeScale）</param>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.GetTimeSpanWithFormat(System.DateTime,System.DateTime,System.String)">
            <summary>
            获取指定显示显示格式的时间跨度表达
            
            {0:00}:{1:00} 分/秒   累加到分钟数
            {0:00}:{1:00}:{2:00} 时/分/秒   累加到小时数
            </summary>
            <param name="startTime">起点日期</param>
            <param name="endTime">结束日期</param>
            <param name="format">返回的日期格式</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.GetTimeSpanWithFormat(System.TimeSpan,System.String)">
            <summary>
            获取指定显示显示格式的时间跨度表达
            </summary>
            <param name="span"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.GetUTCTimeStamp">
            <summary>
            获取当前UTC时间戳Timestamp
            </summary>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.GetUTCTimeStamp(System.DateTime)">
            <summary>
            获取UTC时间戳Timestamp
            </summary>
            <param name="dt">UTC日期</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.GetUTCDateTime(System.Int64)">
            <summary>
            UTC 时间戳Timestamp转换成UTC日期
            </summary>
            <param name="timeStamp">需要转换的时间戳秒</param>
            <returns>返回的UTC日期</returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.GetTimeStamp">
            <summary>
            获取当前时间戳Timestamp
            </summary>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.GetTimeStamp(System.DateTime)">
            <summary>
            获取时间戳Timestamp
            </summary>
            <param name="dt">日期</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.GetDateTime(System.Int64)">
            <summary>
            时间戳Timestamp转换成日期
            </summary>
            <param name="timeStamp">需要转换的时间戳秒</param>
            <returns>返回的日期</returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.World2UIPos(UnityEngine.Vector3,UnityEngine.Camera,UnityEngine.Camera,UnityEngine.RectTransform)">
            <summary>
            世界坐标转UI坐标
            </summary>
            <param name="targetWorldPos">对象世界坐标</param>
            <param name="mainCam">主摄像机</param>
            <param name="uiCam">UI相机</param>
            <param name="uiCanvas">被放置的UICANVAS节点</param>
            <returns>被放置的UI世界坐标，设置其 transform.position即可。（没有返回UI坐标的Vector2是为了避免容器父节点坐标影响)</returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.UI2WorldPos(UnityEngine.RectTransform)">
            <summary>
            UI坐标转世界坐标
            </summary>
            <param name="uiTarget">目标UI对象</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.ScreenToLocalPos(UnityEngine.Vector3,UnityEngine.Transform,UnityEngine.Camera)">
            <summary>
            屏幕坐标转3D坐标系的本地坐标
            </summary>
            <param name="screenPos">屏幕坐标</param>
            <param name="parent">3D位置在世界中的父对象</param>
            <param name="mainCam">所参照的世界主相机</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.ScreenToCanvasPos(UnityEngine.Canvas,UnityEngine.Vector3,UnityEngine.Camera)">
            <summary>
            世界坐标向特定画布坐标转换
            </summary>
            <param name="canvas">画布</param>
            <param name="screen">屏幕坐标</param>
            <param name="uiCam">UICam</param>
            <returns>返回画布上的二维坐标</returns>
        </member>
        <member name="M:LitFramework.LitTool.LitTool.CreateLinkStyle(UnityEngine.UI.Text,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            动态对文本创建下划线。Text组件
            </summary>
            <param name="target">Text组件</param>
            <param name="contents">显示文本内容</param>
            <param name="style">下滑线类型，默认为'_'</param>
            <param name="alignByGeometry">是否使用几何对齐</param>
            <param name="richText">是否支持富文本</param>
        </member>
        <member name="T:LitFramework.LitTool.MonoForCorouting">
            <summary>
            全局使用的monobehaivor
            </summary>
        </member>
        <member name="T:LitFramework.LitTool.DelayFuncDecoration">
            <summary>
            延迟调用函数包装类
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.DelayFuncDecoration.DelayFuncEventHandler(System.Single)">
            <summary>
            时间判定回调
            </summary>
            <param name="nowTime"></param>
        </member>
        <member name="T:LitFramework.LitTool.TextureCapture">
            <summary>
            截屏功能
            </summary>
        </member>
        <member name="T:LitFramework.LitTool.TextureCapture.CaptureSize">
            <summary>
            截图尺寸
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.TextureCapture.SaveCapture(UnityEngine.Camera,LitFramework.LitTool.TextureCapture.CaptureSize,System.String,System.String,System.Single,System.Single)">
            <summary>
            保存截图 ，默认存储于TempPath
            </summary>
            <param name="targetCamera">目标摄像机</param>
            <param name="captureSize">截图尺寸</param>
            <param name="outPutName">文件名称</param>
            <param name="outPut">存储路径 - 外部输入格式: AssetPathManager.Instance.GetTemporaryCachePath( outPutName , false )</param>
            <param name="fixedSizeX">指定截图尺寸下的纵横像素值X</param>
            <param name="fixedSizeY">指定截图尺寸下的纵横像素值Y</param>
        </member>
        <member name="M:LitFramework.LitTool.TextureCapture.Capture(UnityEngine.Camera)">
            <summary> 相机截图 </summary>
            <param name="camera">目标相机,设备屏幕宽高</param>
        </member>
        <member name="M:LitFramework.LitTool.TextureCapture.GetTexture2d(UnityEngine.RenderTexture)">
            <summary>
            从RenderTexture处获取Texture2D
            </summary>
            <param name="renderT"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.TextureCapture.Capture(UnityEngine.Camera,System.Int32,System.Int32)">
            <summary> 相机截图 </summary>
            <param name="camera">目标相机</param>
            <param name="width">宽度</param>
            <param name="height">高度</param>
        </member>
        <member name="M:LitFramework.LitTool.TextureCapture.SaveTexture(System.String,UnityEngine.Texture2D)">
            <summary> 保存贴图 </summary>
            <param name="path">保存路径</param>
            <param name="texture">Texture2D</param>
        </member>
        <member name="M:LitFramework.LitTool.TextureCapture.Texture2DToRendertexture(UnityEngine.Texture2D,System.Int32,System.Int32)">
            <summary>
            Texture2D 转换为 RenderTexture
            </summary>
            <param name="targetT">需要转换的Texture2D</param>
            <param name="imgWidth">目标RenderTexture像素宽度</param>
            <param name="imgHeiht">目标RenderTexture像素高度</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.TextureCapture.Texture2DToSprite(UnityEngine.Texture2D,System.Int32,System.Int32)">
            <summary>
            Texture2D 转换为 Sprite
            </summary>
            <param name="targetT">需要转换的Texture2D</param>
            <param name="ImageWidth">目标RenderTexture像素宽度</param>
            <param name="imageHeight">目标RenderTexture像素高度</param>
            <returns></returns>
        </member>
        <member name="T:LitFramework.LitTool.ResourceManager">
            <summary>
            待完善-基于resource.load的图集加载、assetbundle、文件加载等
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.IDownLoadVersion">
            <summary>
            更新流程说明：<see href="https://www.processon.com/view/link/61013cd4637689719d2d8166">流程图</see>
            </summary>
        </member>
        <member name="P:LitFramework.LitTool.ResourceManager.ABFilePath">
            <summary>
            AB包路径
            </summary>
        </member>
        <member name="P:LitFramework.LitTool.ResourceManager.MainABName">
            <summary>
            主包名字
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.LoadAB(System.String)">
            <summary>
            加载AB包
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.LoadFromAB``1(System.String)">
            <summary>
            从AB包中加载资源
            </summary>
            <typeparam name="T"></typeparam>
            <param name="abName"></param>
            <param name="resName"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.RemoveMenory">
            <summary>
            卸载没有被使用的资源
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.ClearOneAB(System.String)">
            <summary>
            卸载单个AB包
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.ClearAll">
            <summary>
            卸载所有AB包
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.DownLoadABIE(System.String)">
            <summary>
            当所有资源下载完成或者更新完成,开始游戏
            </summary>
            <param name="abName"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.IDoLoadFileUWR(System.String,System.Boolean)">
            <summary>
            加载 .txt/ .dat/ .csv等文件
            </summary>
            <param name="searchPath">要加载文件的【带后缀】完整路径 Application.streamingAssetsPath+ "Csv/CutTool.csv"</param>
            <param name="useRawDataArray">true - 返回的是download data    false - 直接返回结果字符串</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.IDoLoadTextureUWR(System.String)">
            <summary>
            加载png 等图像格式
            </summary>
            <param name="searchPath">要加载文件的【带后缀】完整路径 Application.streamingAssetsPath+ "Csv/CutTool.csv"</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.IDoLoadAssetBundleUWR(System.String)">
            <summary>
            加载AssetBundle
            </summary>
            /// <param name="searchPath">要加载文件的【带后缀】完整路径 Application.streamingAssetsPath+ "Csv/CutTool.csv"</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitTool.ResourceManager.LoadSpriteAtlas(System.String,System.String)">
            <summary>
            加载图集中的子对象
            </summary>
            <param name="spriteName"></param>
            <param name="atlasPath"></param>
            <returns></returns>
        </member>
        <member name="T:LitFramework.LitTool.ABVersion">
            <summary>
            csv资源文件内容
            </summary>
        </member>
        <member name="T:LitFramework.LitTool.SpriteAdapter">
            <summary>
            对SpriteRender纹理进行Camera.main摄像机边界尺寸的调整
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.SpriteAdapter.ResizeOrt">
            <summary>
            正交适配
            </summary>
        </member>
        <member name="M:LitFramework.LitTool.SpriteAdapter.ResiezeProj">
            <summary>
            透视适配
            </summary>
        </member>
        <member name="T:LitFramework.AudioManager">
            <summary>
            音频组建更新
            
            创建时需要外传加载方法。相关配置采用的是PlayerPrefs方式保存
            </summary>
        </member>
        <member name="P:LitFramework.AudioManager.VolumeSE">
            <summary>
            音效音量
            </summary>
        </member>
        <member name="P:LitFramework.AudioManager.VolumeBGM">
            <summary>
            音乐音量
            </summary>
        </member>
        <member name="M:LitFramework.AudioManager.Install">
            <summary>
            启动音频模块
            </summary>
            <param name="loadFunction">提供音频加载方法</param>
        </member>
        <member name="M:LitFramework.AudioManager.Uninstall">
            <summary>
            卸载模块
            </summary>
        </member>
        <member name="M:LitFramework.AudioManager.GetBGM(System.String)">
            <summary>
            获取音乐
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.AudioManager.GetSE(System.String)">
            <summary>
            获取音效
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.AudioManager.PlaySE(System.String,System.Boolean,System.Boolean,System.Single)">
            <summary>
            播放音效
            修改：
            用栈管理多个音效组件，处理同时存在的多个持续存在的声音效果
            </summary>
            <param name="name">音频文件显示名称</param>
            <param name="loop">是否循环播放</param>
            <param name="isParallel">是否与其它音效并行播放</param>
            <param name="volumeRate">此音频播放音量，0-1</param>
        </member>
        <member name="M:LitFramework.AudioManager.StopSE(System.String)">
            <summary>
            停止持续播放的音效
            只针对loop声效有效
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:LitFramework.AudioManager.StopAllSE">
            <summary>
            关闭全部音效
            </summary>
        </member>
        <member name="P:LitFramework.AudioManager.CurrentMusicName">
            <summary>
            当前播放的音乐名称
            </summary>
        </member>
        <member name="M:LitFramework.AudioManager.PlayBGM(System.String,System.Boolean)">
            <summary>
            播放音乐
            </summary>
            <param name="name"></param>
            <param name="loop"></param>
        </member>
        <member name="M:LitFramework.AudioManager.PauseBGM">
            <summary>
            暂停音乐
            </summary>
        </member>
        <member name="M:LitFramework.AudioManager.StopBGM">
            <summary>
            停止音乐
            </summary>
        </member>
        <member name="M:LitFramework.AudioManager.ResumeBGM">
            <summary>
            继续播放音乐
            </summary>
        </member>
        <member name="M:LitFramework.AudioManager.OnBGMValumeChange(System.Single)">
            <summary>
            侦听音量改变
            </summary>
            <param name="vol"></param>
        </member>
        <member name="M:LitFramework.AudioManager.OnSEValumeChange(System.Single)">
            <summary>
            侦听音乐改变
            </summary>
            <param name="vol"></param>
        </member>
        <member name="M:LitFramework.AudioManager.PlaySoloSE(System.String)">
            <summary>
            播放独立音效，单次且不可覆盖播放
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:LitFramework.Singleton`1">
            <summary>
            非组件单例基类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:LitFramework.Singleton`1._instance">
            <summary>
            volatile多用于多线程的环境，当一个变量定义为volatile时，读取这个变量的值时候每次都是从momery里面读取而不是从cache读。这样做是为了保证读取该变量的信息都是最新的，而无论其他线程如何更新这个变量。
            </summary>
        </member>
        <member name="M:LitFramework.Singleton`1.DoDestroy">
            <summary>
            移除
            </summary>
        </member>
        <member name="T:LitFramework.SingletonMono`1">
            <summary>
            组件单例基类
            </summary>
            <typeparam name="T">继承子类类名</typeparam>
            
        </member>
        <member name="M:LitFramework.SingletonMono`1.DoDestroy">
            <summary>
            移除
            </summary>
        </member>
        <member name="E:LitFramework.InputSystem.InputControlManager.EscapeCallBack">
            <summary>
            点击返回键
            </summary>
        </member>
        <member name="F:LitFramework.InputSystem.InputControlManager.IsTouchedContinuePressCallBack">
            <summary>
            是否持续点击触发
            </summary>
        </member>
        <member name="F:LitFramework.InputSystem.InputControlManager.IsTouchedOnUICallBack">
            <summary>
            是否点击到UI反馈
            </summary>
        </member>
        <member name="E:LitFramework.InputSystem.InputControlManager.FingerZoomCallback">
            <summary>
            双指|鼠标滚轮放大程度
            </summary>
        </member>
        <member name="E:LitFramework.InputSystem.InputControlManager.FingerRotateCallBack">
            <summary>
            双指滑动相对上次记录偏移角度。顺时针计算
            </summary>
        </member>
        <member name="P:LitFramework.InputSystem.InputControlManager.CurrentIsOnUI">
            <summary>
            当前是否在点击UI
            </summary>
        </member>
        <member name="P:LitFramework.InputSystem.InputControlManager.IsEnable">
            <summary>
            鼠标点击操作功能是否开启
            </summary>
        </member>
        <member name="T:LitFramework.LitPool.SpawnManager">
            <summary>
            对外控制用脚本
            </summary>
        </member>
        <member name="M:LitFramework.LitPool.SpawnManager.Install">
            <summary>
            初始化并获取对象池
            </summary>
        </member>
        <member name="M:LitFramework.LitPool.SpawnManager.Uninstall">
            <summary>
            卸载模块
            </summary>
        </member>
        <member name="M:LitFramework.LitPool.SpawnManager.SpwanObject(System.String)">
            <summary>
            从对象池中获取一个对象
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.LitPool.SpawnManager.DespawnObject(UnityEngine.Transform)">
            <summary>
            回收入对象池
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:LitFramework.TimeRecord.ZeroTimeRecord">
            <summary>
            零点访问器。用于单机版本记录零点刷新
            单机做零点刷新，一般就以本地时间即可
            </summary>
        </member>
        <member name="T:LitFramework.UI.Base.UIModelBehavior">
            <summary>
            提供一个表进行动态修改UI状态
            </summary>
        </member>
        <member name="M:LitFramework.UI.Base.UIModelBehavior.SetUIBehavior(System.String,UIType)">
            <summary>
            动态修改UICurrentUIType属性
            </summary>
            <param name="uiName"></param>
            <param name="currentUIType"></param>
        </member>
        <member name="M:LitFramework.UI.Base.UIModelBehavior.RemoveUIBehavior(System.String)">
            <summary>
            移除临时修改得UI CurrentUIType属性
            </summary>
            <param name="uiName"></param>
        </member>
        <member name="M:LitFramework.UI.Base.UIModelBehavior.GetBehavior(System.String)">
            <summary>
            获取UI CurrentUIType属性，如果并未对特定UI设定属性，则为空
            </summary>
            <param name="uiName"></param>
            <returns></returns>
        </member>
        <member name="P:LitFramework.Mono.BaseUI.IsShowing">
            <summary>
            该窗口是否开启中
            </summary>
        </member>
        <member name="P:LitFramework.Mono.BaseUI.CurrentUIType">
            <summary>
            当前窗口类型
            </summary>
        </member>
        <member name="P:LitFramework.Mono.BaseUI.IsStarted">
            <summary>
            是否执行过Start
            </summary>
        </member>
        <member name="P:LitFramework.Mono.BaseUI.AssetsName">
            <summary>
            资源名
            </summary>
        </member>
        <member name="F:LitFramework.Mono.BaseUI.IsInitOver">
            <summary>
            创建完毕标记，用于控制UI预制件在第一次创建出来时，不要自动触发OnEnable
            </summary>
        </member>
        <member name="F:LitFramework.Mono.BaseUI._hasEnabled">
            <summary>
            这个标记的作用是，一个隐藏的UI被重新激活，会自动触发OnEnable，会与框架中Show方法自动触发OnEnabled（如果IsShow为False）
            </summary>
        </member>
        <member name="M:LitFramework.Mono.BaseUI.Show(System.Boolean)">
            <summary>
            显示窗体
            </summary>
            <param name="replay">会传bool到 OnEnable/OnDisable</param>
        </member>
        <member name="M:LitFramework.Mono.BaseUI.CheckMask">
            <summary>
            检测并显示模态窗体背景
            </summary>
        </member>
        <member name="M:LitFramework.Mono.BaseUI.Close(System.Boolean,System.Boolean)">
            <summary>
            隐藏窗口
            </summary>
            <param name="isDestroy">是否摧毁并彻底释放</param>
            <param name="freeze">是否暂时冻结，会传bool到 OnEnable/OnDisable</param>
        </member>
        <member name="M:LitFramework.Mono.BaseUI.OnShow">
            <inheritdoc/>
             <remarks>
             刷新窗体
             </remarks>
        </member>
        <member name="M:LitFramework.Mono.BaseUI.OnBackPushed">
            <summary>
            点击返回事件
            </summary>
        </member>
        <member name="T:LitFramework.Mono.UIManager">
            <summary>
            以下UI类，需配合UImanager.unitypackage使用。
            
            主要包含Cavas_Root及相关Tag等
            
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.TransRoot">
            <summary>
            UI根节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.TransNormal">
            <summary>
            普通窗口节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.TransFixed">
            <summary>
            固定UI节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.TransPopUp">
            <summary>
            弹出窗口节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.TransGlobal">
            <summary>
            顶级窗口节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.RectransRoot">
            <summary>
            UI根节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.RectransNormal">
            <summary>
            普通窗口节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.RectransFixed">
            <summary>
            固定UI节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.RectransPopUp">
            <summary>
            弹出窗口节点
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.RectransGlobal">
            <summary>
            弹出窗口节点
            </summary>
        </member>
        <member name="F:LitFramework.Mono.UIManager.LoadResourceFunc">
            <summary>
            外部传入UI的加载方法。Resource.Load || AssetBundle.Load
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.UICam">
            <summary>
            UI摄像机
            </summary>
        </member>
        <member name="F:LitFramework.Mono.UIManager._fadeImage">
            <summary>
            全局渐变遮罩
            </summary>
        </member>
        <member name="E:LitFramework.Mono.UIManager.DelHideCallBack">
            <summary>
             遮罩结束时回调
            </summary>
            <returns></returns>
        </member>
        <member name="P:LitFramework.Mono.UIManager.FadeImage">
            <summary>
            Image_fadeBG控制类，一般用于全局黑屏转场。
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.MaskImage">
            <summary>
            PopUp 类弹窗所使用的背景蒙版，默认颜色为黑色
            </summary>
        </member>
        <member name="P:LitFramework.Mono.UIManager.CanvasScaler">
            <summary>
            UI适配策略
            </summary>
        </member>
        <member name="F:LitFramework.Mono.UIManager._allRegisterUIList">
            <summary>
            所有的预制件名称列表
            </summary>
        </member>
        <member name="F:LitFramework.Mono.UIManager._stackCurrentUI">
            <summary>
            //定义“栈”集合,存储显示当前所有弹出窗口的窗体类型
            </summary>
        </member>
        <member name="F:LitFramework.Mono.UIManager._dictLoadedAllUIs">
            <summary>
            缓存已经开启过的所有窗体
            </summary>
        </member>
        <member name="F:LitFramework.Mono.UIManager._dictCurrentShowUIs">
            <summary>
            当前显示的非弹出类UI窗体
            </summary>
        </member>
        <member name="M:LitFramework.Mono.UIManager.ShowFade(System.Action,System.Single)">
            <summary>
            隐退开始
            </summary>
            <param name="time"></param>
            <param name="callBack"></param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.HideFade(System.Action,System.Single)">
            <summary>
            隐退结束
            </summary>
            <param name="time"></param>
            <param name="callBack"></param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.Show(System.String)">
            <summary>
            显示（打开）UI窗口
            功能：
            1、根据UI窗体的名称，加载到UI窗口缓存列表
            2、根据不同UI显示模式，做不同的加载处理
            </summary>
            <param name="uiName">UI窗体预制件名称</param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.Close(System.String,System.Boolean)">
            <summary>
            关闭指定UI
            </summary>
            <param name="uiName"></param>
            <param name="isDestroy">是否直接释放所有资源，销毁</param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.ClearPopUpStackArray">
            <summary>
            清空弹出窗口栈
            </summary>
        </member>
        <member name="M:LitFramework.Mono.UIManager.LoadUIToAndFromAllList(System.String)">
            <summary>
            根据UI预制件名称加载到UI缓存列表（按需），同时获取实例
            </summary>
            <param name="uiName"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.Mono.UIManager.LoadUI(System.String)">
            <summary>
            加载指定名称UI
            功能：
            1、根据名称加载预制体
            2、根据UI类型加载到不同节点下
            3、隐藏创建的UI克隆体
            4、把克隆体加入到所有窗体列表
            </summary>
            <param name="uiName">窗体名称</param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.Mono.UIManager.LoadParallelUI(System.String)">
            <summary>
            加载当前窗体到当前窗体集合
            </summary>
            <param name="uiName"></param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.UnLoadParallelUI(System.String,System.Boolean)">
            <summary>
            从当前UI列表缓存中卸载UI窗体
            </summary>
            <param name="uiName"></param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.LoadUniqueUI(System.String)">
            <summary>
            加载独占UI窗体
            </summary>
            <param name="uiName"></param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.UnLoadUniqueUI(System.String,System.Boolean)">
            <summary>
            卸载当前UI，并将原先被隐藏的UI重新显示
            </summary>
            <param name="uiName"></param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.LoadStackUI(System.String)">
            <summary>
            弹出窗口，入栈
            先冻结栈中窗口，再将此窗口入栈
            </summary>
            <param name="uiName"></param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.UnLoadStackUI(System.String,System.Boolean)">
            <summary>
            弹出窗口，出栈
            </summary>
            <param name="uiName"></param>
        </member>
        <member name="M:LitFramework.Mono.UIManager.GetUIByName(System.String)">
            <summary>
            从现有缓存中查找目标UI，未加载则返回null
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:LitFramework.Mono.UIManager.OnEscapeCallback">
            <summary>
            返回键执行关闭窗口操作
            </summary>
        </member>
        <member name="T:GameDriver">
            <summary>
            框架驱动器。提供Update FixedUpdate LateUpdate驱动
            </summary>
        </member>
        <member name="E:GameDriver.DelZeroTime">
            <summary>
            零点刷新回调
            </summary>
        </member>
        <member name="T:LitFrameworkFacade">
            <summary>
            总启动器。
            包含各个模块的初始化统一初始化
            </summary>
        </member>
        <member name="M:LitFrameworkFacade.StartUp(System.Action,System.Action,System.Boolean)">
            <summary>
            框架启动
            </summary>
            <param name="afterExecuteFunc">框架启动完成后，依次执行的自定义方法</param>
            <param name="beforeExecuteFunc">框架启动前，依次执行的自定义方法。主要是项目中顺次执行本地数据加载</param>
            <param name="debugEnable">框架启动时是否开启日志</param>
        </member>
        <member name="T:PathologicalGames.SpawnPool">
            <description>
            Online Docs: 
                http://docs.poolmanager2.path-o-logical.com/code-reference/spawnpool
                
            A special List class that manages object pools and keeps the scene 
            organized.
            
             * Only active/spawned instances are iterable. Inactive/despawned
               instances in the pool are kept internally only.
            
             * Instanciated objects can optionally be made a child of this GameObject
               (reffered to as a 'group') to keep the scene hierachy organized.
            	 
             * Instances will get a number appended to the end of their name. E.g. 
               an "Enemy" prefab will be called "Enemy(Clone)001", "Enemy(Clone)002", 
               "Enemy(Clone)003", etc. Unity names all clones the same which can be
               confusing to work with.
            	   
             * Objects aren't destroyed by the Despawn() method. Instead, they are
               deactivated and stored to an internal queue to be used again. This
               avoids the time it takes unity to destroy gameobjects and helps  
               performance by reusing GameObjects. 
            	   
             * Two events are implimented to enable objects to handle their own reset needs. 
               Both are optional.
                 1) When objects are Despawned BroadcastMessage("OnDespawned()") is sent.
            	 2) When reactivated, a BroadcastMessage("OnRespawned()") is sent. 
            	    This 
            </description>
        </member>
        <member name="F:PathologicalGames.SpawnPool.poolName">
            <summary>
            Returns the name of this pool used by PoolManager. This will always be the
            same as the name in Unity, unless the name contains the work "Pool", which
            PoolManager will strip out. This is done so you can name a prefab or
            GameObject in a way that is development friendly. For example, "EnemiesPool" 
            is easier to understand than just "Enemies" when looking through a project.
            </summary>
        </member>
        <member name="F:PathologicalGames.SpawnPool.matchPoolScale">
            <summary>
            Matches new instances to the SpawnPool GameObject's scale.
            </summary>
        </member>
        <member name="F:PathologicalGames.SpawnPool.matchPoolLayer">
            <summary>
            Matches new instances to the SpawnPool GameObject's layer.
            </summary>
        </member>
        <member name="F:PathologicalGames.SpawnPool.dontReparent">
            <summary>
            If True, do not reparent instances under the SpawnPool's Transform.
            </summary>
        </member>
        <member name="P:PathologicalGames.SpawnPool.dontDestroyOnLoad">
            <summary>
            If true, the Pool's group, GameObject, will be set to Unity's 
            Object.DontDestroyOnLoad()
            </summary>
        </member>
        <member name="F:PathologicalGames.SpawnPool.logMessages">
            <summary>
            Print information to the Unity Console
            </summary>
        </member>
        <member name="F:PathologicalGames.SpawnPool.perPrefabPoolOptions">
            <summary>
            A list of PreloadDef options objects used by the inspector for user input
            </summary>
        </member>
        <member name="F:PathologicalGames.SpawnPool.prefabsFoldOutStates">
            <summary>
            Used by the inspector to store this instances foldout states.
            </summary>
        </member>
        <member name="F:PathologicalGames.SpawnPool.maxParticleDespawnTime">
            <summary>
            The time in seconds to stop waiting for particles to die.
            A warning will be logged if this is triggered.
            </summary>
        </member>
        <member name="P:PathologicalGames.SpawnPool.group">
            <summary>
            The group is an empty game object which will be the parent of all
            instances in the pool. This helps keep the scene easy to work with.
            </summary>
        </member>
        <member name="F:PathologicalGames.SpawnPool.prefabs">
            <summary>
            Returns the prefab of the given name (dictionary key)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:PathologicalGames.SpawnPool.prefabPools" -->
        <member name="M:PathologicalGames.SpawnPool.OnDestroy">
            <summary>
            Runs when this group GameObject is destroyed and executes clean-up
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.CreatePrefabPool(PrefabPool)">
            <summary>
            Creates a new PrefabPool in this Pool and instances the requested 
            number of instances (set by PrefabPool.preloadAmount). If preload 
            amount is 0, nothing will be spawned and the return list will be empty.
            
            It is rare this function is needed during regular usage.
            This function should only be used if you need to set the preferences
            of a new PrefabPool, such as culling or pre-loading, before use. Otherwise, 
            just use Spawn() and if the prefab is used for the first time a PrefabPool 
            will automatically be created with defaults anyway.
            
            Note: Instances with ParticleEmitters can be preloaded too because 
                  it won't trigger the emmiter or the coroutine which waits for 
                  particles to die, which Spawn() does.
                  
            Usage Example:
                // Creates a prefab pool and sets culling options but doesn't
                //   need to spawn any instances (this is fine)
                PrefabPool prefabPool = new PrefabPool()
                prefabPool.prefab = myPrefabReference;
                prefabPool.preloadAmount = 0;
                prefabPool.cullDespawned = True;
                prefabPool.cullAbove = 50;
                prefabPool.cullDelay = 30;
                
                // Enemies is just an example. Any pool is fine.
                PoolManager.Pools["Enemies"].CreatePrefabPool(prefabPool);
                
                // Then, just use as normal...
                PoolManager.Pools["Enemies"].Spawn(myPrefabReference);
            </summary>
            <param name="prefabPool">A PrefabPool object</param>
            <returns>A List of instances spawned or an empty List</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Add(UnityEngine.Transform,System.String,System.Boolean,System.Boolean)">
            <summary>
            Add an existing instance to this pool. This is used during game start 
            to pool objects which are not instanciated at runtime
            </summary>
            <param name="instance">The instance to add</param>
            <param name="prefabName">
            The name of the prefab used to create this instance
            </param>
            <param name="despawn">True to depawn on start</param>
            <param name="parent">True to make a child of the pool's group</param>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Add(UnityEngine.Transform)">
            <summary>
            Not Implimented. Use Spawn() to properly add items to the pool.
            This is required because the prefab needs to be stored in the internal
            data structure in order for the pool to function properly. Items can
            only be added by instencing them using SpawnInstance().
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Remove(UnityEngine.Transform)">
            <summary>
            Not Implimented. Use Despawn() to properly manage items that should remain 
            in the Queue but be deactivated. There is currently no way to safetly
            remove items from the pool permentantly. Destroying Objects would
            defeat the purpose of the pool.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <description>
            Spawns an instance or creates a new instance if none are available.
            Either way, an instance will be set to the passed position and 
            rotation.
            
            Detailed Information:
            Checks the Data structure for an instance that was already created
            using the prefab. If the prefab has been used before, such as by
            setting it in the Unity Editor to preload instances, or just used
            before via this function, one of its instances will be used if one
            is available, or a new one will be created.
            
            If the prefab has never been used a new PrefabPool will be started 
            with default options. 
            
            To alter the options on a prefab pool, use the Unity Editor or see
            the documentation for the PrefabPool class and 
            SpawnPool.SpawnPrefabPool()
            	
            Broadcasts "OnSpawned" to the instance. Use this to manage states.
            	
            An overload of this function has the same initial signature as Unity's 
            Instantiate() that takes position and rotation. The return Type is different 
            though. Unity uses and returns a GameObject reference. PoolManager 
            uses and returns a Transform reference (or other supported type, such 
            as AudioSource and ParticleSystem)
            </description>
            <param name="prefab">
            The prefab used to spawn an instance. Only used for reference if an 
            instance is already in the pool and available for respawn. 
            NOTE: Type = Transform
            </param>
            <param name="pos">The position to set the instance to</param>
            <param name="rot">The rotation to set the instance to</param>
            <param name="parent">An optional parent for the instance</param>
            <returns>
            The instance's Transform. 
            
            If the Limit option was used for the PrefabPool associated with the
            passed prefab, then this method will return null if the limit is
            reached. You DO NOT need to test for null return values unless you 
            used the limit option.
            </returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            See primary Spawn method for documentation.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(UnityEngine.Transform)">
            <summary>
            See primary Spawn method for documentation.
            
            Overload to take only a prefab and instance using an 'empty' 
            position and rotation.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            See primary Spawn method for documentation.
            
            Convienince overload to take only a prefab  and parent the new 
            instance under the given parent
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(System.String)">
            <summary>
            See primary Spawn method for documentation.
            
            Overload to take only a prefab name. The cached reference is pulled  
            from the SpawnPool.prefabs dictionary.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(System.String,UnityEngine.Transform)">
            <summary>
            See primary Spawn method for documentation.
            
            Convienince overload to take only a prefab name and parent the new 
            instance under the given parent
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(System.String,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            See primary Spawn method for documentation.
            
            Overload to take only a prefab name. The cached reference is pulled from 
            the SpawnPool.prefabs dictionary. An instance will be set to the passed 
            position and rotation.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(System.String,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <summary>
            See primary Spawn method for documentation.
            
            Convienince overload to take only a prefab name and parent the new 
            instance under the given parent. An instance will be set to the passed 
            position and rotation.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(UnityEngine.ParticleSystem,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            See docs for SpawnInstance(Transform prefab, Vector3 pos, Quaternion rot)
            for basic functionalty information.
            	
            Pass a ParticleSystem component of a prefab to instantiate, trigger 
            emit, then listen for when all particles have died to "auto-destruct", 
            but instead of destroying the game object it will be deactivated and 
            added to the pool to be reused.
            
            IMPORTANT: 
                * You must pass a ParticleSystem next time as well, or the emitter
                  will be treated as a regular prefab and simply activate, but emit
                  will not be triggered!
                * The listner that waits for the death of all particles will 
                  time-out after a set number of seconds and log a warning. 
                  This is done to keep the developer aware of any unexpected 
                  usage cases. Change the public property "maxParticleDespawnTime"
                  to adjust this length of time.
            
            Broadcasts "OnSpawned" to the instance. Use this instead of Awake()
            	
            This function has the same initial signature as Unity's Instantiate() 
            that takes position and rotation. The return Type is different though.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Spawn(UnityEngine.ParticleSystem,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <summary>
            See primary Spawn ParticleSystem method for documentation.
            
            Convienince overload to take only a prefab name and parent the new 
            instance under the given parent. An instance will be set to the passed 
            position and rotation.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Despawn(UnityEngine.Transform)">
            <summary>
            If the passed object is managed by the SpawnPool, it will be 
            deactivated and made available to be spawned again.
            	
            Despawned instances are removed from the primary list.
            </summary>
            <param name="item">The transform of the gameobject to process</param>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Despawn(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            See docs for Despawn(Transform instance) for basic functionalty information.
            	
            Convienince overload to provide the option to re-parent for the instance 
            just before despawn.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Despawn(UnityEngine.Transform,System.Single)">
            <description>
            See docs for Despawn(Transform instance). This expands that functionality.
              If the passed object is managed by this SpawnPool, it will be 
              deactivated and made available to be spawned again.
            </description>
            <param name="item">The transform of the instance to process</param>
            <param name="seconds">The time in seconds to wait before despawning</param>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Despawn(UnityEngine.Transform,System.Single,UnityEngine.Transform)">
            <summary>
            See docs for Despawn(Transform instance) for basic functionalty information.
            	
            Convienince overload to provide the option to re-parent for the instance 
            just before despawn.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.DoDespawnAfterSeconds(UnityEngine.Transform,System.Single,System.Boolean,UnityEngine.Transform)">
            <summary>
            Waits X seconds before despawning. See the docs for DespawnAfterSeconds()
            the argument useParent is used because a null parent is valid in Unity. It will 
            make the scene root the parent
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.DespawnAll">
            <description>
            Despawns all active instances in this SpawnPool
            </description>
        </member>
        <member name="M:PathologicalGames.SpawnPool.IsSpawned(UnityEngine.Transform)">
            <description>
            Returns true if the passed transform is currently spawned.
            </description>
            <param name="item">The transform of the gameobject to test</param>
        </member>
        <member name="M:PathologicalGames.SpawnPool.GetPrefabPool(UnityEngine.Transform)">
            <summary>
            Returns the prefab pool for a given prefab.
            </summary>
            <param name="prefab">The Transform of an instance</param>
            <returns>PrefabPool</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.GetPrefabPool(UnityEngine.GameObject)">
            <summary>
            Returns the prefab pool for a given prefab.
            </summary>
            <param name="prefab">The GameObject of an instance</param>
            <returns>PrefabPool</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.GetPrefab(UnityEngine.Transform)">
            <summary>
            Returns the prefab used to create the passed instance. 
            This is provided for convienince as Unity doesn't offer this feature.
            </summary>
            <param name="instance">The Transform of an instance</param>
            <returns>Transform</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.GetPrefab(UnityEngine.GameObject)">
            <summary>
            Returns the prefab used to create the passed instance. 
            This is provided for convienince as Unity doesn't offer this feature.
            </summary>
            <param name="instance">The GameObject of an instance</param>
            <returns>GameObject</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.ToString">
            <summary>
            Returns a formatted string showing all the spawned member names
            </summary>
        </member>
        <member name="P:PathologicalGames.SpawnPool.Item(System.Int32)">
            <summary>
            Read-only index access. You can still modify the instance at the given index.
            Read-only reffers to setting an index to a new instance reference, which would
            change the list. Setting via index is never needed to work with index access.
            </summary>
            <param name="index">int address of the item to get</param>
            <returns></returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.Contains(UnityEngine.Transform)">
            <summary>
            The name "Contains" is misleading so IsSpawned was implimented instead.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.CopyTo(UnityEngine.Transform[],System.Int32)">
            <summary>
            Used by OTHERList.AddRange()
            This adds this list to the passed list
            </summary>
            <param name="array">The list AddRange is being called on</param>
            <param name="arrayIndex">
            The starting index for the copy operation. AddRange seems to pass the last index.
            </param>
        </member>
        <member name="P:PathologicalGames.SpawnPool.Count">
            <summary>
            Returns the number of items in this (the collection). Readonly.
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPool.GetEnumerator">
            <summary>
            Impliments the ability to use this list in a foreach loop
            </summary>
            <returns></returns>
        </member>
        <member name="M:PathologicalGames.SpawnPool.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Impliments the ability to use this list in a foreach loop
            </summary>
            <returns></returns>
        </member>
        <member name="T:PathologicalGames.PoolManager">
            <description>
            PoolManager v2.0
             - PoolManager.Pools is not a complete implimentation of the IDictionary interface
               Which enabled:
                   * Much more acurate and clear error handling
                   * Member access protection so you can't run anything you aren't supposed to.
             - Moved all functions for working with Pools from PoolManager to PoolManager.Pools
               which enabled shorter names to reduces the length of lines of code.
            Online Docs: http://docs.poolmanager2.path-o-logical.com
            </description>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.Create(System.String)">
            <summary>
            Creates a new GameObject with a SpawnPool Component which registers itself
            with the PoolManager.Pools dictionary. The SpawnPool can then be accessed 
            directly via the return value of this function or by via the PoolManager.Pools 
            dictionary using a 'key' (string : the name of the pool, SpawnPool.poolName).
            </summary>
            <param name="poolName">
            The name for the new SpawnPool. The GameObject will have the word "Pool"
            Added at the end.
            </param>
            <returns>A reference to the new SpawnPool component</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.Create(System.String,UnityEngine.GameObject)">
             <summary>
            Creates a SpawnPool Component on an 'owner' GameObject which registers 
             itself with the PoolManager.Pools dictionary. The SpawnPool can then be 
             accessed directly via the return value of this function or via the
             PoolManager.Pools dictionary.
             </summary>
             <param name="poolName">
             The name for the new SpawnPool. The GameObject will have the word "Pool"
             Added at the end.
             </param>
             <param name="owner">A GameObject to add the SpawnPool Component</param>
             <returns>A reference to the new SpawnPool component</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.assertValidPoolName(System.String)">
            <summary>
            Used to ensure a name is valid before creating anything.
            </summary>
            <param name="poolName">The name to test</param>
            <returns>True if sucessful, false if failed.</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.ToString">
            <summary>
            Returns a formatted string showing all the pool names
            </summary>
            <returns></returns>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.Destroy(System.String)">
            <summary>
            Destroy an entire SpawnPool, including its GameObject and all children.
            You can also just destroy the GameObject directly to achieve the same result.
            This is really only here to make it easier when a reference isn't at hand.
            </summary>
            <param name="spawnPool"></param>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.DestroyAll">
            <summary>
            Destroy ALL SpawnPools, including their GameObjects and all children.
            You can also just destroy the GameObjects directly to achieve the same result.
            This is really only here to make it easier when a reference isn't at hand.
            </summary>
            <param name="spawnPool"></param>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.Add(PathologicalGames.SpawnPool)">
            <summary>
            Used internally by SpawnPools to add themseleves on Awake().
            Use PoolManager.CreatePool() to create an entirely new SpawnPool GameObject
            </summary>
            <param name="spawnPool"></param>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.Remove(PathologicalGames.SpawnPool)">
            <summary>
            Used internally by SpawnPools to remove themseleves on Destroy().
            Use PoolManager.Destroy() to destroy an entire SpawnPool GameObject.
            </summary>
            <param name="spawnPool"></param>
        </member>
        <member name="P:PathologicalGames.SpawnPoolsDict.Count">
            <summary>
            Get the number of SpawnPools in PoolManager
            </summary>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.ContainsKey(System.String)">
            <summary>
            Returns true if a pool exists with the passed pool name.
            </summary>
            <param name="poolName">The name to look for</param>
            <returns>True if the pool exists, otherwise, false.</returns>
        </member>
        <member name="M:PathologicalGames.SpawnPoolsDict.TryGetValue(System.String,PathologicalGames.SpawnPool@)">
            <summary>
            Used to get a SpawnPool when the user is not sure if the pool name is used.
            This is faster than checking IsPool(poolName) and then accessing Pools][poolName.]
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Cloneable`1.Clone">
            <summary>
            基础覆写方法
            </summary>
            <returns></returns>
        </member>
        <member name="T:CSVReader">
            <summary>
            编辑器部分的同步文件，如果有改动需要在两边共同修改
            </summary>
        </member>
        <member name="M:CSVReader.ParseCSV(System.String)">
            <summary>
            解析csv数据
            </summary>
            <param name="csv"></param>
        </member>
        <member name="M:CSVReader.GetData(System.Int32,System.Int32)">
            <summary>
            获取数据
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="F:GuideShaderController._target">
            <summary>
            要高亮显示的目标
            </summary>
        </member>
        <member name="F:GuideShaderController._corners">
            <summary>
            区域范围缓存
            </summary>
        </member>
        <member name="F:GuideShaderController._center">
            <summary>
            镂空区域圆心
            </summary>
        </member>
        <member name="F:GuideShaderController._radius">
            <summary>
            镂空区域半径
            </summary>
        </member>
        <member name="F:GuideShaderController._material">
            <summary>
            遮罩材质
            </summary>
        </member>
        <member name="F:GuideShaderController._currentRadius">
            <summary>
            当前高亮区域的半径
            </summary>
        </member>
        <member name="F:GuideShaderController._shrinkVelocity">
            <summary>
            收缩速度
            </summary>
        </member>
        <member name="M:GuideShaderController.ChangeTarget(UnityEngine.UI.Image,System.Action)">
            <summary>
            聚焦到引导目标
            TODO 这个地方需要增加对场景3D物体的特定点击回调操作
            </summary>
            <param name="operateImage">目标点击区域Button Image</param>
            <param name="callBack"></param>
        </member>
        <member name="M:GuideShaderController.CurrentGuideOver">
            <summary>
            引导完成后UI重置
            </summary>
        </member>
        <member name="M:GuideShaderController.ResetGuide">
            <summary>
            重置引导画面-去除镂空区域
            </summary>
        </member>
        <member name="M:GuideShaderController.OnClickTargetButtonGuideDone">
            <summary>
            新手引导UI点击回调
            </summary>
        </member>
        <member name="M:GuideShaderController.OnTouchTargetGuideDone">
            <summary>
            3D物体触碰回调
            </summary>
        </member>
        <member name="T:GuideConfig">
            <summary>
            引导动画配置
            </summary>
        </member>
        <member name="T:GuideDataModel">
            <summary>
            分部类。可以在业务逻辑上继续扩展
            </summary>
        </member>
        <member name="F:GuideDataModel.FocusTargetDoneEvent">
            <summary>
            圆形/矩形聚焦完毕回调
            </summary>
        </member>
        <member name="F:GuideDataModel.GuideDoneEvent">
            <summary>
            点击目标位置完成本轮
            </summary>
        </member>
        <member name="T:PrefabPool">
            <summary>
            This class is used to display a more complex user entry interface in the 
            Unity Editor so we can collect more options related to each Prefab.
            
            See this class documentation for Editor Options.
            
            This class is also the primary pool functionality for SpawnPool. SpawnPool
            manages the Pool using these settings and methods. See the SpawnPool 
            documentation for user documentation and usage.
            </summary>
        </member>
        <member name="F:PrefabPool.prefab">
            <summary>
            The prefab to preload
            </summary>
        </member>
        <member name="F:PrefabPool.prefabGO">
            <summary>
            A reference of the prefab's GameObject stored for performance reasons
            </summary>
        </member>
        <member name="F:PrefabPool.preloadAmount">
            <summary>
            The number of instances to preload
            </summary>
        </member>
        <member name="F:PrefabPool.preloadTime">
            <summary>
            Displays the 'preload over time' options
            </summary>
        </member>
        <member name="F:PrefabPool.preloadFrames">
            <summary>
            The number of frames it will take to preload all requested instances
            </summary>
        </member>
        <member name="F:PrefabPool.preloadDelay">
            <summary>
            The number of seconds to wait before preloading any instances
            </summary>
        </member>
        <member name="F:PrefabPool.limitInstances">
             <summary>
             Limits the number of instances allowed in the game. Turning this ON
            	means when 'Limit Amount' is hit, no more instances will be created.
             CALLS TO SpawnPool.Spawn() WILL BE IGNORED, and return null!
            
             This can be good for non-critical objects like bullets or explosion
            	Flares. You would never want to use this for enemies unless it makes
            	sense to begin ignoring enemy spawns in the context of your game.
             </summary>
        </member>
        <member name="F:PrefabPool.limitAmount">
            <summary>
            This is the max number of instances allowed if 'limitInstances' is ON.
            </summary>
        </member>
        <member name="F:PrefabPool.limitFIFO">
            <summary>
            FIFO stands for "first-in-first-out". Normally, limiting instances will
            stop spawning and return null. If this is turned on (set to true) the
            first spawned instance will be despawned and reused instead, keeping the
            total spawned instances limited but still spawning new instances.
            </summary>
        </member>
        <member name="F:PrefabPool.cullDespawned">
            <summary>
            Turn this ON to activate the culling feature for this Pool. 
            Use this feature to remove despawned (inactive) instances from the pool
            if the size of the pool grows too large. 
            
            DO NOT USE THIS UNLESS YOU NEED TO MANAGE MEMORY ISSUES!
            This should only be used in extreme cases for memory management. 
            For most pools (or games for that matter), it is better to leave this 
            off as memory is more plentiful than performance. If you do need this
            you can fine tune how often this is triggered to target extreme events.
            
            A good example of when to use this would be if you you are Pooling 
            projectiles and usually never need more than 10 at a time, but then
            there is a big one-off fire-fight where 50 projectiles are needed. 
            Rather than keep the extra 40 around in memory from then on, set the 
            'Cull Above' property to 15 (well above the expected max) and the Pool 
            will Destroy() the extra instances from the game to free up the memory. 
            
            This won't be done immediately, because you wouldn't want this culling 
            feature to be fighting the Pool and causing extra Instantiate() and 
            Destroy() calls while the fire-fight is still going on. See 
            "Cull Delay" for more information about how to fine tune this.
            </summary>
        </member>
        <member name="F:PrefabPool.cullAbove">
            <summary>
            The number of TOTAL (spawned + despawned) instances to keep. 
            </summary>
        </member>
        <member name="F:PrefabPool.cullDelay">
            <summary>
            The amount of time, in seconds, to wait before culling. This is timed 
            from the moment when the Queue's TOTAL count (spawned + despawned) 
            becomes greater than 'Cull Above'. Once triggered, the timer is repeated 
            until the count falls below 'Cull Above'.
            </summary>
        </member>
        <member name="F:PrefabPool.cullMaxPerPass">
            <summary>
            The maximum number of instances to destroy per this.cullDelay
            </summary>
        </member>
        <member name="F:PrefabPool._logMessages">
            <summary>
            Prints information during run-time to make debugging easier. This will 
            be set to true if the owner SpawnPool is true, otherwise the user's setting
            here will be used
            </summary>
        </member>
        <member name="F:PrefabPool.spawnPool">
            <summary>
            Used internally to reference back to the owner spawnPool for things like
            anchoring co-routines.
            </summary>
        </member>
        <member name="M:PrefabPool.#ctor(UnityEngine.Transform)">
            <description>
            Constructor to require a prefab Transform
            </description>
        </member>
        <member name="M:PrefabPool.#ctor">
            <description>
            Constructor for Serializable inspector use only
            </description>
        </member>
        <member name="M:PrefabPool.inspectorInstanceConstructor">
            <description>
            A pseudo constructor to init stuff not init by the serialized inspector-created
            instance of this class.
            </description>
        </member>
        <member name="M:PrefabPool.SelfDestruct">
            <summary>
            Run by a SpawnPool when it is destroyed
            </summary>
        </member>
        <member name="F:PrefabPool.cullingActive">
            <summary>
            Is set to true when the culling coroutine is started so another one
            won't be
            </summary>
        </member>
        <member name="F:PrefabPool._spawned">
            <summary>
            The active instances associated with this prefab. This is the pool of
            instances created by this prefab.
            
            Managed by a SpawnPool
            </summary>
        </member>
        <member name="F:PrefabPool._despawned">
            <summary>
            The deactive instances associated with this prefab. This is the pool of
            instances created by this prefab.
            
            Managed by a SpawnPool
            </summary>
        </member>
        <member name="P:PrefabPool.totalCount">
            <summary>
            Returns the total count of instances in the PrefabPool
            </summary>
        </member>
        <member name="F:PrefabPool._preloaded">
            <summary>
            Used to make PreloadInstances() a one-time event. Read-only.
            </summary>
        </member>
        <member name="M:PrefabPool.DespawnInstance(UnityEngine.Transform)">
            <summary>
            Move an instance from despawned to spawned, set the position and 
            rotation, activate it and all children and return the transform
            </summary>
            <returns>
            True if successfull, false if xform isn't in the spawned list
            </returns>
        </member>
        <member name="M:PrefabPool.CullDespawned">
            <summary>
            Waits for 'cullDelay' in seconds and culls the 'despawned' list if 
            above 'cullingAbove' amount. 
            
            Triggered by DespawnInstance()
            </summary>
        </member>
        <member name="M:PrefabPool.SpawnInstance(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Move an instance from despawned to spawned, set the position and 
            rotation, activate it and all children and return the transform.
            
            If there isn't an instance available, a new one is made.
            </summary>
            <returns>
            The new instance's Transform. 
            
            If the Limit option was used for the PrefabPool associated with the
            passed prefab, then this method will return null if the limit is
            reached.
            </returns>    
        </member>
        <member name="M:PrefabPool.SpawnNew">
            <summary>
            Spawns a NEW instance of this prefab and adds it to the spawned list.
            The new instance is placed at the passed position and rotation
            </summary>
            <param name="pos">Vector3</param>
            <param name="rot">Quaternion</param>
            <returns>
            The new instance's Transform. 
            
            If the Limit option was used for the PrefabPool associated with the
            passed prefab, then this method will return null if the limit is
            reached.
            </returns>
        </member>
        <member name="M:PrefabPool.SetRecursively(UnityEngine.Transform,System.Int32)">
            <summary>
            Sets the layer of the passed transform and all of its children
            </summary>
            <param name="xform">The transform to process</param>
            <param name="layer">The new layer</param>
        </member>
        <member name="M:PrefabPool.AddUnpooled(UnityEngine.Transform,System.Boolean)">
            <summary>
            Used by a SpawnPool to add an existing instance to this PrefabPool.
            This is used during game start to pool objects which are not 
            instantiated at runtime
            </summary>
            <param name="inst">The instance to add</param>
            <param name="despawn">True to despawn on add</param>
        </member>
        <member name="M:PrefabPool.PreloadInstances">
            <summary>
            Preload PrefabPool.preloadAmount instances if they don't already exist. In 
            otherwords, if there are 7 and 10 should be preloaded, this only creates 3.
            This is to allow asynchronous Spawn() usage in Awake() at game start
            </summary>
            <returns></returns>
        </member>
        <member name="M:PrefabPool.Contains(UnityEngine.Transform)">
            <summary>
            If this PrefabPool spawned or despawned lists contain the given 
            transform, true is returned. Othrewise, false is returned
            </summary>
            <param name="transform">A transform to test.</param>
            <returns>bool</returns>
        </member>
        <member name="M:PrefabPool.nameInstance(UnityEngine.Transform)">
            <summary>
            Appends a number to the end of the passed transform. The number
            will be one more than the total objects in this PrefabPool, so 
            name the object BEFORE adding it to the spawn or depsawn lists.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:PrefabsDict.ToString">
            <summary>
            Returns a formatted string showing all the prefab names
            </summary>
            <returns></returns>
        </member>
        <member name="P:PrefabsDict.Count">
            <summary>
            Get the number of SpawnPools in PoolManager
            </summary>
        </member>
        <member name="M:PrefabsDict.ContainsKey(System.String)">
            <summary>
            Returns true if a prefab exists with the passed prefab name.
            </summary>
            <param name="prefabName">The name to look for</param>
            <returns>True if the prefab exists, otherwise, false.</returns>
        </member>
        <member name="M:PrefabsDict.TryGetValue(System.String,UnityEngine.Transform@)">
            <summary>
            Used to get a prefab when the user is not sure if the prefabName is used.
            This is faster than checking Contains(prefabName) and then accessing the dict
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:MsgManager">
            <summary>
            事件管理器
            
            id内部采用ushort类型，参数采用枚举类型
            </summary>
        </member>
        <member name="M:MsgManager.Register``1(``0,System.Action{MsgArgs})">
            <summary>
            注册事件关注
            </summary>
            <typeparam name="T">统用枚举类。可接受多种枚举。这里会转换为ushort类型。</typeparam>
            <param name="id">Event ID</param>
            <param name="callBack">事件回调</param>
        </member>
        <member name="M:MsgManager.UnRegister``1(``0,System.Action{MsgArgs})">
            <summary>
            取消事件关注
            </summary>
            <typeparam name="T">统用枚举类。可接受多种枚举。这里会转换为ushort类型。<em>通用枚举的转换，采用的是IConvertible.ToUInt16。中间借用了format涉及到了拆装箱，ID转换将会固定产生40B</em></typeparam>
            <param name="id">Event ID</param>
            <param name="callBack">事件回调</param>
        </member>
        <member name="M:MsgManager.Broadcast``1(``0,MsgArgs)">
            <summary>
            广播事件。统用枚举类
            </summary>
            <typeparam name="T">统用枚举类。可接受多种枚举。这里会转换为ushort类型。<em>通用枚举的转换，采用的是IConvertible.ToUInt16。中间借用了format涉及到了拆装箱，ID转换将会固定产生40B</em></typeparam>
            <param name="id">Event ID</param>
            <param name="msg">事件参数</param>
        </member>
        <member name="M:MsgManager.Register(System.UInt16,System.Action{MsgArgs})">
            <summary>
            注册事件关注
            </summary>
            <param name="id">Event ID</param>
            <param name="callBack">事件回调</param>
        </member>
        <member name="M:MsgManager.UnRegister(System.UInt16,System.Action{MsgArgs})">
            <summary>
            取消事件关注
            </summary>
            <param name="id">Event ID</param>
            <param name="callBack">事件回调</param>
        </member>
        <member name="M:MsgManager.Broadcast(System.UInt16,MsgArgs)">
            <summary>
            广播事件
            </summary>
            <param name="id">Event ID</param>
            <param name="msg">事件参数</param>
        </member>
        <member name="M:MsgManager.Register(System.String,System.Action{MsgArgs})">
            <summary>
            注册事件关注。推荐用于临时事件注册
            </summary>
            <param name="id">Event ID</param>
            <param name="callBack">事件回调</param>
        </member>
        <member name="M:MsgManager.UnRegister(System.String,System.Action{MsgArgs})">
            <summary>
            取消事件关注。推荐用于临时事件注册
            </summary>
            <param name="id">Event ID</param>
            <param name="callBack">事件回调</param>
        </member>
        <member name="M:MsgManager.Broadcast(System.String,MsgArgs)">
            <summary>
            广播事件。推荐用于临时事件注册
            </summary>
            <param name="id">Event ID</param>
            <param name="msg">事件参数</param>
        </member>
        <member name="T:MsgArgs">
            <summary>
            消息参数体。
            </summary>
        </member>
        <member name="P:ADManager.UseBackgroundAD">
            <summary>
            是否开启切回前台插页广告
            </summary>
        </member>
        <member name="F:ADManager.CanShowInitialEvent">
            <summary>
            是否需要播放插页广告回调
            </summary>
        </member>
        <member name="P:ADManager.Adapter">
            <summary>
            当前使用中的广告适配器
            </summary>
        </member>
        <member name="P:ADManager.UseAds">
            <summary>
            是否启用广告
            </summary>
        </member>
        <member name="M:ADManager.ShowFullScreen">
            <summary>
            满足 CanShowInitialEvent 回调判定条件，或者直接返回播放插页
            </summary>
        </member>
        <member name="T:BezierViewTest">
            <summary>
            贝塞尔曲线测试类，用于演示
            </summary>
        </member>
        <member name="T:CSExtention">
            <summary>
            方法扩展类
            </summary>
        </member>
        <member name="M:CSExtention.GetCameraBounds(UnityEngine.Camera,System.Single,UnityEngine.Vector3[]@)">
            <summary>
            获取【透视相机】指定距离下相机视口四个角的坐标
            </summary>
            <param name="cam"></param>
            <param name="distance">相对于相机的距离</param>
            <param name="corners">lenth==4</param>
            <returns></returns>
        </member>
        <member name="M:CSExtention.GetCameraBounds(UnityEngine.Camera,UnityEngine.Vector3[]@)">
            <summary>
            获取【正交相机】视口四个角的坐标
            </summary>
            <param name="cam"></param>
            <param name="corners">lenth==4</param>
            <returns></returns>
        </member>
        <member name="M:CSExtention.IdentityTransform(UnityEngine.Transform)">
            <summary>
            localscale=0，localPosition=0，localRotation=identity
            </summary>
            <param name="trans"></param>
        </member>
        <member name="M:CSExtention.RandomSortList``1(System.Collections.Generic.List{``0})">
            <summary>
            数组内随机排列
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:CSExtention.GetGrayMat">
            <summary>
            创建置灰材质球
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSExtention.SetUIGray(UnityEngine.UI.Image)">
            <summary>
            图片置灰
            </summary>
        </member>
        <member name="M:CSExtention.SetUIGrayRecover(UnityEngine.UI.Image)">
            <summary>
            图片回复
            </summary>
        </member>
        <member name="M:LitJson.JsonData.ContainsKey(System.String)">
            <summary>
            Determines whether the json contains an element that has the specified key.
            </summary>
            <param name="key">The key to locate in the json.</param>
            <returns>true if the json contains an element that has the specified key; otherwise, false.</returns>
        </member>
        <member name="M:UnityEngine.LMath.VectorAngle(UnityEngine.Vector2,UnityEngine.Vector2,System.Boolean)">
            <summary>
            返回 -180°~180°/ 0°~180° 向量夹角
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="fromZero">是否最小值为0°。默认为 False</param>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.LMath.RandomWeightIndex(System.Collections.Generic.List{System.Int32})">
            <summary>
            得到权重的随机数
            </summary>
            <param name="prob">权重值列表</param>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.LMath.BezierCurve(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            根据T值，计算贝塞尔曲线给定三点下相对应的点
            
            二阶公式：result = (1-t)srq2p0 + 2t(1-t)p1 + tsqr2p2
            </summary>
            <param name="t"></param>T值
            <param name="P0"></param>起始点
            <param name="P1"></param>控制点
            <param name="P2"></param>目标点
            <returns>根据T值计算出来的贝赛尔曲线点</returns>
        </member>
        <member name="M:UnityEngine.LMath.GetBeizerList(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Int32)">
            <summary>
            获取存储贝塞尔曲线点的数组
            </summary>
            <param name="startPoint"></param>起始点
            <param name="controlPoint"></param>控制点
            <param name="endPoint"></param>目标点
            <param name="segmentNum"></param>采样点的数量
            <returns></returns>存储贝塞尔曲线点的数组
        </member>
        <member name="M:UnityEngine.LMath.ClosestPointOnLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2@,System.Single@)">
            <summary>
            点到线段最近的一个点位置和距离
            </summary>
            <param name="linePt1"> 线段起始点</param>
            <param name="linePt2"> 线段终点</param>
            <param name="point">任意一点</param>
            <param name="retPoint">out 相交点</param>
            <param name="d">out 点到线段的最近距离</param>
            <returns>是否有垂线与线段相交</returns>
        </member>
        <member name="M:UnityEngine.LMath.IsPointInPoly(UnityEngine.Vector2,UnityEngine.Vector2[])">
            <summary>
            2D坐标下某点是否存在于多边形内
            </summary>
            <param name="testPoint"></param>
            <param name="poly"></param>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.LMath.IsPointOnLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            判断点是否在直线上
            </summary>
            <param name="point">任意点</param>
            <param name="start">直线起点</param>
            <param name="end">直线终点</param>
            <returns>返回值越接近0就是表示点越靠近反之越远。当为0时，点完全在线上</returns>
        </member>
        <member name="M:UnityEngine.LMath.IsParallel(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            判断两个向量是否平行
            </summary>
            <param name="line1"></param>
            <param name="line2"></param>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.LMath.IsVertical(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            判断两个向量是否平行
            </summary>
            <param name="line1"></param>
            <param name="line2"></param>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.LMath.CalcLineIntersection(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2@)">
            <summary>
            判断两个直线的交点。如果不相交将会抛出警告并返回Vector.Zero
            </summary>
            <param name="p1">第一根直线</param>
            <param name="p2">第一根直线</param>
            <param name="p3">第二根直线</param>
            <param name="p4">第二根直线</param>
            <param name="result">返回相交点</param>
            <returns>如果平行则返回false， 否则为true</returns>
        </member>
        <member name="M:UnityEngine.LMath.CalcIncludedAngle3D(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            计算两个3D向量的夹角
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns> -180 ---- 180</returns>
        </member>
        <member name="M:UnityEngine.LMath.CalcIncludedAngle2D(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            计算两个2D向量的夹角
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns> -180 ---- 180</returns>
        </member>
        <member name="M:UnityEngine.LMath.CalcGamaObjectBoundsInWorld(UnityEngine.GameObject)">
            <summary>
            获取GameObject包围盒
            </summary>
            <param name="go"></param>
            <returns></returns>
        </member>
        <member name="F:UIType.isClearPopUp">
            <summary>
            是否需要清空弹出窗口栈
            </summary>
        </member>
        <member name="F:UIType.uiNodeType">
            <summary>
            UI窗体挂载的节点类型
            </summary>
        </member>
        <member name="F:UIType.uiShowMode">
            <summary>
            UI窗体显示方式
            Normal - 示窗体与其他窗体可以同时显示
            PopUp - 多层弹窗，同时需要维护多个弹出窗口并依次恢复显示的情况
            Unique - 独占窗口，显示时其他界面隐藏
            </summary>
        </member>
        <member name="F:UIType.uiTransparent">
            <summary>
            UI窗体透明度类型(PopUp 类型时生效)
            </summary>
        </member>
        <member name="T:UIMaskManager">
            <summary>
            遮罩控制器。用于控制Image_Mask显示行为
            </summary>
        </member>
        <member name="P:UIMaskManager.Mask">
            <summary>
            当前Image_Maskm蒙版的Image对象
            </summary>
        </member>
        <member name="F:UIMaskManager.MaskEnableEventHandler">
            <summary>
            背景遮罩启用/关闭事件。接收参数bool表明是否启用。
            目前发生时机，是开关PopUp弹窗时，各会触发一次
            </summary>
        </member>
        <member name="M:UIMaskManager.SetMaskEnable(UITransparentEnum)">
            <summary>
            根据传入枚举类型，激活蒙版并完成对应显示状态
            </summary>
            <param name="transparent">透明度级别</param>
        </member>
        <member name="M:UIMaskManager.SetMaskWindow(UnityEngine.GameObject,UITransparentEnum)">
            <summary>
            设置指定UI的遮罩状态
            </summary>
            <param name="displayUIForms">需要为其服务的UIGameObject，比如UIMain所挂载的对象</param>
            <param name="transparent">透明度级别</param>
        </member>
        <member name="M:UIMaskManager.CancelMaskWindow">
            <summary>
            取消遮罩
            </summary>
        </member>
        <member name="M:UIMaskManager.SetMaskColor(UnityEngine.Color)">
            <summary>
            设置Mask Image蒙版的颜色。不会影响Alpha值
            </summary>
            <param name="color">对应颜色。可通过ColorUtility.TryParseHtmlString转码获得 </param>
        </member>
        <member name="T:UINodeTypeEnum">
            <summary>
            引导挂载到不同节点
            </summary>
        </member>
        <member name="F:UINodeTypeEnum.Normal">
            <summary>
            节点 - 普通窗体
            <para>一般性可拖动</para>
            </summary>
        </member>
        <member name="F:UINodeTypeEnum.Fixed">
            <summary>
            节点 - 固定窗体
            <para>用于最底层的全屏界面UI   </para>
            </summary>
        </member>
        <member name="F:UINodeTypeEnum.PopUp">
            <summary>
            节点 - 弹出窗体，可使用黑色遮罩
            </summary>
        </member>
        <member name="F:UINodeTypeEnum.Global">
            <summary>
            节点 - 顶级窗体，高于Mask背景遮罩
            </summary>
        </member>
        <member name="T:UIShowModeEnum">
            <summary>
            窗体显示方式
            </summary>
        </member>
        <member name="F:UIShowModeEnum.Parallel">
            <summary>
            展示窗体与其他窗体可以同时显示
            </summary>
        </member>
        <member name="F:UIShowModeEnum.Stack">
            <summary>
            多层弹窗，同时需要维护多个弹出窗口并依次恢复显示的情况
            </summary>
        </member>
        <member name="F:UIShowModeEnum.Unique">
            <summary>
            独占窗口，显示时其他界面隐藏
            </summary>
        </member>
        <member name="T:UITransparentEnum">
            <summary>
            定义模态窗体的透明度
            </summary>
        </member>
        <member name="F:UITransparentEnum.NoPenetratingLow">
            <summary>
            低透明，不可穿透
            </summary>
        </member>
        <member name="F:UITransparentEnum.NoPenetratingMiddle">
            <summary>
            半透明，不可穿透
            </summary>
        </member>
        <member name="F:UITransparentEnum.NoPenetratingTotal">
            <summary>
            透明，不可穿透
            </summary>
        </member>
        <member name="F:UITransparentEnum.Penetrating">
            <summary>
            可穿透
            </summary>
        </member>
        <member name="M:UnityHelper.FindTheChildNode(UnityEngine.Transform,System.String)">
            <summary>
            查找子节点对象
            内部使用递归算法
            </summary>
            <param name="goParent">父对象</param>
            <param name="chiildName">查找的子对象名称</param>
            <returns></returns>
        </member>
        <member name="M:UnityHelper.GetTheChildNodeComponetScripts``1(UnityEngine.Transform,System.String)">
            <summary>
            获取子节点（对象）脚本
            </summary>
            <typeparam name="T">泛型</typeparam>
            <param name="goParent">父对象</param>
            <param name="childName">子对象名称</param>
            <returns></returns>
        </member>
        <member name="M:UnityHelper.AddChildNodeCompnent``1(UnityEngine.Transform,System.String)">
            <summary>
            给子节点添加脚本
            
            <para>如果已经有相同的脚本了，则先删除</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="goParent">父对象</param>
            <param name="childName">子对象名称</param>
            <returns></returns>
        </member>
        <member name="M:UnityHelper.AddChildNodeToParentNode(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            给子节点添加父对象
            <para>添加完成后本地坐标、尺寸、旋转角度归零</para>
            </summary>
            <param name="parents">父对象的方位</param>
            <param name="child">子对象的方法</param>
        </member>
    </members>
</doc>
